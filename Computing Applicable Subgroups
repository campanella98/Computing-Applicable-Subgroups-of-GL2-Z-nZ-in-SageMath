// Sage code for my thesis
// by Alessandro Campanella

def GL2ModuleInvariants(V):
    """
    Compute the abelian group invariants of a Z/nZ-submodule of Z/nZ x Z/nZ
    """

    # Define n earlier to avoid repeating len(V.base_ring())
    n = len(V.base_ring())
    # Check if the module has no generators
    if len(V.gens()) == 0:
        return []

    # Check if the module has one generator. Use set() to avoid duplicates in the list.
    if len(V.gens()) == 1:
        # Calculate #V
        V_elements = [tuple(a * V.gens()[0]) for a in range(n)]
        return [len(set(V_elements))]

    # Assert there are at most 2 generators
    assert len(V.gens()) <= 2

    # The list of elements generated by the first generator
    firstgen_list = set([tuple(a * V.gens()[0]) for a in range(n)])

    # The list of elements generated by the second generator
    secondgen_list = set([tuple(a * V.gens()[1]) for a in range(n)])

    # Compute r1 and r2 upfront
    r1 = len(firstgen_list)
    r2 = len(secondgen_list)

    # Function to check if two vectors are dependent
    def are_dependent(v, list):
        return v in list

    # Check if the generators are dependent (checking both conditions)
    if are_dependent(tuple(V.gens()[1]), firstgen_list) or are_dependent(tuple(V.gens()[0]), secondgen_list):  
        # If dependent, return max(r1, r2)
        rmax = max(r1, r2)
        return [rmax]

    # If not dependent (linearly independent), return gcd and lcm
    return [gcd(r1, r2), lcm(r1, r2)]
