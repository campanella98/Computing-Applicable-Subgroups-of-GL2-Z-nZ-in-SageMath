// Sage code for my thesis
// by Alessandro Campanella


def GL2ModuleInvariants(V):
    """
    The function GL2ModuleInvariants(V) computes the abelian group invariants of a Z/nZ-submodule of Z/nZ x Z/nZ. 
    The function assumes that V is generated by at most two elements.
    """

    # Define n earlier to avoid repeating len(V.base_ring())
    n = len(V.base_ring())
    # Check if the module has no generators
    if len(V.gens()) == 0:
        return []

    # Check if the module has one generator. Use set() to avoid duplicates in the list.
    if len(V.gens()) == 1:
        # Calculate #V
        V_elements = [tuple(a * V.gens()[0]) for a in range(n)]
        return [len(set(V_elements))]

    # Assert there are at most 2 generators
    assert len(V.gens()) <= 2

    # The list of elements generated by the first generator
    firstgen_list = set([tuple(a * V.gens()[0]) for a in range(n)])

    # The list of elements generated by the second generator
    secondgen_list = set([tuple(a * V.gens()[1]) for a in range(n)])

    # Compute r1 and r2 upfront
    r1 = len(firstgen_list)
    r2 = len(secondgen_list)

    # Function to check if two vectors are dependent
    def are_dependent(v, list):
        return v in list

    # Check if the generators are dependent (checking both conditions)
    if are_dependent(tuple(V.gens()[1]), firstgen_list) or are_dependent(tuple(V.gens()[0]), secondgen_list):  
        # If dependent, return max(r1, r2)
        rmax = max(r1, r2)
        return [rmax]

    # If not dependent (linearly independent), return gcd and lcm
    return [gcd(r1, r2), lcm(r1, r2)]



def find_largest_order_element(generator_list):
    """
    The function find largest order element(generator list) iterates through the list of generators of a submodule, 
    computes the order of each element, and returns the element from the list that
    corresponds to the largest computed order.
    """

    largest_order = 0
    largest_order_element = generator_list[0]  # Initialize to the first element

    for element in generator_list:
        order = element.order()

        if order > largest_order:
            largest_order = order
            largest_order_element = element

    return largest_order_element



def SubmoduleRank(V):
    """
    The function SubmoduleRank(V) reduces the generator list of a submodule V of Z/nZ x Z/nZ to at most two generators, 
    prioritizing combinations involving the generator of highest order.
    """
    R = V[0][0].base_ring()
    M = R^2
    V_sub = M.submodule(V) 
    generators = V_sub.gens()
    n = len(R)

    if len(generators) == 0:
        return M.submodule([])  # Submodule gen. by (0,0)

    if len(generators) == 1:
        return M.submodule([generators[0]])  # Submodule with one generator

    #m is the index of one of the generators with the highest order
    m = generators.index(find_largest_order_element(generators))

    #V_elements is the set with all the elements in V 
    V_elements = set(V)

    # Iterate through pairs of generators
    for i in range(len(generators)):  
        if set([tuple(a*generators[m]+(b*generators[i])) for a in range(n) for b in range(n)]) == V_elements:
            return M.submodule([generators[m], generators[i]])

    # If it doesn't work this may mean that the generators require more than 2 generators.
    return V  # If we can't find a submodule generated by just the first generator and another, return V!



from sage.modules.free_module_element import vector
from sage.matrix.constructor import Matrix

def GL2FixModule(H):
    """
    Given a subgroup of GL(2, Z/nZ), computes the invariants of the submodule
    of Z/nZ x Z/nZ fixed by the left action of H.

    Args:
        H: A matrix group representing a subgroup of GL(2, Z/nZ).  The
           elements of H should be Sage matrices.

    Returns:
        A list: [], [a], or [a, b] with a | b | n, representing the abelian
        group invariants of the fixed submodule.  Here | denotes "divides".
    """

    # Determine the ring Z/nZ
    R = H.base_ring()
    M = R^2

    # Find the submodule fixed by the left action of H.
    # Start with all of (Z/nZ)^2. In Magma this is Eigenspace(Identity(H),1);

    V = [(x, y) for x in R for y in R] # (Z/nZ)^2 represented as a list of tuples

    # In Magma take of transpose h_sage (Magma default is right action!)
    for h in H.gens(): #Iterate over the generators, as that is sufficient.
       new_V = []
       for v in V:
            v = vector(R, list(v))
            h_sage = Matrix(R,h) #Convert h to a standard Sage matrix
            if (h_sage * v == v):
              new_V.append(tuple(v))
       V = [value for value in V if value in new_V]


    """
    SubmoduleRank(V) limits the generating set to two elements. However,
    the two generating elements may not be linearly independent so inside
    the GL2ModuleInvariants(V) function, we have an extra filter to deal with that.
    """
 
    V_twogen = SubmoduleRank(V) 

    return GL2ModuleInvariants(V_twogen)



def GL2IsSubModule(A, B):
    """
    Given invariants A and B of two Z/nZ-submodules of Z/nZ x Z/nZ,
    return True if A is isomorphic to a submodule of B.

    Args:
        A: A list of invariants for the first Z/nZ-submodule.
        B: A list of invariants for the second Z/nZ-submodule.

    Returns:
        True if A is isomorphic to a submodule of B, False otherwise.
    """
    i = len(B) - len(A)
    if i < 0:
        return False

    # loop with python 0-based indexing
    for j in range(len(A)):
        if B[i + j] % A[j] != 0: # python indexing starts at 0.  Magma starts at 1.
            return False

    return True



def GL2ContainsCC(H):
    """
    Given a subgroup H of GL(2, Z/nZ), returns True if H contains an element
    corresponding to complex conjugation.

    This is tested by checking det = -1, tr = 0, and fixing a maximal cyclic
    subgroup.

    Args:
        H: A matrix group representing a subgroup of GL(2, Z/nZ). The
           elements of H should be Sage matrices.

    Returns:
        True if H contains an element corresponding to complex conjugation,
        False otherwise.
    """
    R = H.base_ring()
    found = False
    for h in H:
        h_sage = Matrix(R, h)
        if h_sage.det() == -1 and h_sage.trace() == 0:

            #Check this element to see if its' GL2SubModule stuff works.
            invariants_base_ring = [R.cardinality()] # size of R = Z/nZ
            cyclic_group = H.subgroup([h])
            invariants_fixed_module = GL2FixModule(cyclic_group)
            if GL2IsSubModule(invariants_base_ring, invariants_fixed_module):
                found = True
                break  # Exit the loop early once a suitable element is found

    return found



def GL2Subgroups_with_surjectivedet_CC(n):
    """
    Computes all subgroups of GL(2, Z/nZ) that have surjective determinant maps and
    contains an element conjugate to complex conjugation.

    Args:
        n: The modulus for GL(2, Z/nZ).

    Returns:
        A list of subgroups of GL(2, Z/nZ) with surjective determinant maps and
        containing an element conjugate to complex conjugation.
    """
    # Define GL(2, Z/nZ)
    GLN = GL(2, IntegerModRing(n))

    # Get the set of numbers coprime to n
    coprime_set = set(x for x in range(1, n) if gcd(x, n) == 1)

    # Generate all possible subgroups (this may be slow for large n)
    subgroups = GLN.conjugacy_classes_subgroups()
    
    if n >= 9:
        subgroups = [H for H in subgroups if not H.is_abelian()]

    # List to store subgroups with surjective determinant maps and CC
    surjectiveCC_subgroups = []

    for H in subgroups:
        # Compute the set of determinants for this subgroup
        determinants = {mat.matrix().det() for mat in H}

        # If the set of determinants is equal to the set of numbers coprime to n
        if determinants == coprime_set:
            if GL2ContainsCC(H) == True:
                surjectiveCC_subgroups.append(H)

    return surjectiveCC_subgroups
